import java.awt.*;
import javax.swing.*;
import java.util.Random;

public class Maze extends JPanel implements Runnable {
//author vanshksingh
    public static void main(String[] args) {
        JFrame window = new JFrame("Maze Solver");
        window.setContentPane(new Maze());
        window.pack();
        window.setLocation(120, 80);
        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        window.setVisible(true);
    }

    // Define the maze grid and cell types
    int[][] maze;
    final static int BACKGROUND = 0;
    final static int WALL = 1;
    final static int PATH = 2;
    final static int EMPTY = 3;
    final static int VISITED = 4;
    Color[] colors;  // Colors for maze elements
    int rows = 41;  // Number of rows in the maze
    int columns = 51;  // Number of columns in the maze
    int border = 0;  // Border width
    int sleepTime = 5000;  // Sleep time after solving
    int speedSleep = 30;  // Sleep time during solving
    int blockSize = 12;  // Size of each cell
    int width = -1;  // Width of the maze panel
    int height = -1;  // Height of the maze panel
    int totalWidth;  // Total width of the maze grid
    int totalHeight;  // Total height of the maze grid
    int left;  // Left offset for drawing the maze
    int top;  // Top offset for drawing the maze
    boolean mazeExists = false;  // Indicates if the maze has been generated
    boolean solving = false;  // Indicates if the maze is currently being solved

    // Constructor for the Maze class
    public Maze() {
        colors = generateMazeColors();  // Generate maze colors
        setBackground(colors[BACKGROUND]);
        setPreferredSize(new Dimension(blockSize * columns, blockSize * rows));
        new Thread(this).start();  // Start the maze solving thread
    }

    // Generate a palette of colors for the maze
    Color[] generateMazeColors() {
        // Define color palettes for the maze (add more palettes if needed)
        Color[][] colorPalettes = new Color[][] {
                {
                        // Background Color (Dark)
                        new Color(0x222222),
                        // Wall Color (Light)
                        new Color(0xFFFFFF),
                        // Empty Space Color (Dark)
                        new Color(0x222222),
                        // Path Color (Inverse of Wall)
                        new Color(0xF3A963),
                        // Visited Path Color (Darker version of Path)
                        new Color(0xDC6606)
                },
                // Add more color palettes here
        };

        Random random = new Random();
        int randomPaletteIndex = random.nextInt(colorPalettes.length);
        return colorPalettes[randomPaletteIndex];
    }

    // Generate a contrasting color for maze elements
    Color generateContrastingColor(Color background) {
        Random random = new Random();
        int red = random.nextInt(256);
        int green = random.nextInt(256);
        int blue = random.nextInt(256);

        Color foreground = new Color(red, green, blue);

        // Ensure sufficient contrast between background and foreground colors
        if (getContrastRatio(background, foreground) < 4.5) {
            return generateContrastingColor(background);
        }

        return foreground;
    }

    // Calculate the contrast ratio between two colors
    double getContrastRatio(Color color1, Color color2) {
        int l1 = getLuminance(color1);
        int l2 = getLuminance(color2);
        return (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);
    }

    // Calculate the luminance of a color
    int getLuminance(Color color) {
        int red = color.getRed();
        int green = color.getGreen();
        int blue = color.getBlue();
        return (int) (0.299 * red + 0.587 * green + 0.114 * blue);
    }

    // Check if the size of the maze panel has changed
    void checkSize() {
        if (getWidth() != width || getHeight() != height) {
            width = getWidth();
            height = getHeight();
            int w = (width - 2 * border) / columns;
            int h = (height - 2 * border) / rows;
            left = (width - w * columns) / 2;
            top = (height - h * rows) / 2;
            totalWidth = w * columns;
            totalHeight = h * rows;
        }
    }

    // Override the paintComponent method to redraw the maze
    synchronized protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        checkSize();
        redrawMaze(g);
    }

    // Redraw the maze with appropriate colors
    void redrawMaze(Graphics g) {
        if (mazeExists) {
            int w = totalWidth / columns;
            int h = totalHeight / rows;
            for (int j = 0; j < columns; j++) {
                for (int i = 0; i < rows; i++) {
                    if (maze[i][j] < 0) {
                        g.setColor(colors[EMPTY]);
                    } else {
                        g.setColor(colors[maze[i][j]]);
                    }
                    g.fillRect((j * w) + left, (i * h) + top, w, h);
                }
            }
        }
    }

    // Runnable method to control maze generation and solving
    public void run() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
        }
        while (true) {
            makeMaze();
            solving = true;
            boolean solved = solveMaze(1, 1);
            solving = false;
            if (solved) {
                synchronized (this) {
                    try {
                        Thread.sleep(sleepTime);
                    } catch (InterruptedException e) {
                    }
                }
            }
            mazeExists = false;
            repaint();
        }
    }

    // Generate the maze grid
    void makeMaze() {
        if (maze == null)
            maze = new int[rows][columns];
        int i, j;
        int emptyCt = 0;
        int wallCt = 0;
        int[] wallrow = new int[(rows * columns) / 2];
        int[] wallcol = new int[(rows * columns) / 2];
        for (i = 0; i < rows; i++)
            for (j = 0; j < columns; j++)
                maze[i][j] = WALL;
        for (i = 1; i < rows - 1; i += 2)
            for (j = 1; j < columns - 1; j += 2) {
                emptyCt++;
                maze[i][j] = -emptyCt;
                if (i < rows - 2) {
                    wallrow[wallCt] = i + 1;
                    wallcol[wallCt] = j;
                    wallCt++;
                }
                if (j < columns - 2) {
                    wallrow[wallCt] = i;
                    wallcol[wallCt] = j + 1;
                    wallCt++;
                }
            }
        mazeExists = true;
        repaint();
        int r;
        for (i = wallCt - 1; i > 0; i--) {
            r = (int) (Math.random() * i);
            tearDown(wallrow[r], wallcol[r]);
            wallrow[r] = wallrow[i];
            wallcol[r] = wallcol[i];
        }
        for (i = 1; i < rows - 1; i++)
            for (j = 1; j < columns - 1; j++)
                if (maze[i][j] < 0)
                    maze[i][j] = EMPTY;
    }

    // Tear down walls to create paths in the maze
    synchronized void tearDown(int row, int col) {
        if (row % 2 == 1 && maze[row][col - 1] != maze[row][col + 1]) {
            fill(row, col - 1, maze[row][col - 1], maze[row][col + 1]);
            maze[row][col] = maze[row][col + 1];
            repaint();
            try {
                Thread.sleep(speedSleep);
            } catch (InterruptedException e) {
            }
        } else if (row % 2 == 0 && maze[row - 1][col] != maze[row + 1][col]) {
            fill(row - 1, col, maze[row - 1][col], maze[row + 1][col]);
            maze[row][col] = maze[row + 1][col];
            repaint();
            try {
                Thread.sleep(speedSleep);
            } catch (InterruptedException e) {
            }
        }
    }

    // Fill the maze with a specified value
    void fill(int row, int col, int replace, int replaceWith) {
        if (maze[row][col] == replace) {
            maze[row][col] = replaceWith;
            fill(row + 1, col, replace, replaceWith);
            fill(row - 1, col, replace, replaceWith);
            fill(row, col + 1, replace, replaceWith);
            fill(row, col - 1, replace, replaceWith);
        }
    }

    // Solve the maze using a recursive algorithm
    boolean solveMaze(int row, int col) {
        if (maze[row][col] == EMPTY) {
            maze[row][col] = PATH;
            repaint();
            try {
                Thread.sleep(speedSleep);
            } catch (InterruptedException e) {
            }
            if (row == rows - 2 && col == columns - 2)
                return true;
            if (solveMaze(row - 1, col) || solveMaze(row, col - 1) || solveMaze(row + 1, col) || solveMaze(row, col + 1)) {
                return true;
            }
            maze[row][col] = VISITED;
            repaint();
            try {
                Thread.sleep(speedSleep);
            } catch (InterruptedException e) {
            }
        }
        return false;
    }
}
