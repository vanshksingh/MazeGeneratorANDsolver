import java.awt.*;
import javax.swing.*;
import java.util.Random;

public class Maze extends JPanel implements Runnable {
    int[][] maze;
    int rows = 41;
    int columns = 51;
    int blockSize = 12;
    int wallCode = 1;
    int pathCode = 0;
    int startRow = 1;
    int startCol = 1;
    int endRow = rows - 2;
    int endCol = columns - 2;

    Color[] color;
    int width = -1;
    int height = -1;
    int totalWidth;
    int totalHeight;
    int left;
    int top;

    public Maze() {
        color = new Color[] {
            new Color(200, 0, 0),
            new Color(128, 128, 255),
            Color.WHITE
        };
        setBackground(color[pathCode]);
        setPreferredSize(new Dimension(blockSize * columns, blockSize * rows);
        new Thread(this).start();
    }

    void checkSize() {
        if (getWidth() != width || getHeight() != height) {
            width = getWidth();
            height = getHeight();
            int w = (width - 2) / columns;
            int h = (height - 2) / rows;
            left = (width - w * columns) / 2;
            top = (height - h * rows) / 2;
            totalWidth = w * columns;
            totalHeight = h * rows;
        }
    }

    synchronized protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        checkSize();
        redrawMaze(g);
    }

    void redrawMaze(Graphics g) {
        int w = totalWidth / columns;
        int h = totalHeight / rows;

        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < columns; c++) {
                int x = left + c * w;
                int y = top + r * h;
                g.setColor(color[maze[r][c]]);
                g.fillRect(x, y, w, h);
            }
        }
    }

    public void run() {
        maze = new int[rows][columns];
        createMaze(startRow, startCol);
    }

    void createMaze(int r, int c) {
        maze[r][c] = pathCode;
        int[] dirs = {1, 2, 3, 4};
        for (int i = 0; i < dirs.length; i++) {
            int j = (int) (Math.random() * 4);
            int temp = dirs[i];
            dirs[i] = dirs[j];
            dirs[j] = temp;
        }
        for (int i = 0; i < dirs.length; i++) {
            int dir = dirs[i];
            int newRow = r;
            int newCol = c;
            if (dir == 1) {
                newCol = c + 1;
            } else if (dir == 2) {
                newRow = r + 1;
            } else if (dir == 3) {
                newCol = c - 1;
            } else {
                newRow = r - 1;
            }
            if (maze[newRow][newCol] == wallCode) {
                maze[r + (newRow - r) / 2][c + (newCol - c) / 2] = pathCode;
                createMaze(newRow, newCol);
            }
        }
        if (r % 2 == 1 && c % 2 == 1) {
            return;
        }
        int[] dirs2 = {1, 2, 3, 4};
        for (int i = 0; i < dirs2.length; i++) {
            int j = (int) (Math.random() * 4);
            int temp = dirs2[i];
            dirs2[i] = dirs2[j];
            dirs2[j] = temp;
        }
        for (int i = 0; i < dirs2.length; i++) {
            int dir = dirs2[i];
            int newRow = r;
            int newCol = c;
            if (dir == 1) {
                newCol = c + 1;
            } else if (dir == 2) {
                newRow = r + 1;
            } else if (dir == 3) {
                newCol = c - 1;
            } else {
                newRow = r - 1;
            }
            if (maze[newRow][newCol] == wallCode) {
                maze[r + (newRow - r) / 2][c + (newCol - c) / 2] = pathCode;
                createMaze(newRow, newCol);
            }
        }
    }

    public static void main(String[] args) {
        JFrame window = new JFrame("Maze Solver");
        window.setContentPane(new Maze());
        window.pack();
        window.setLocation(120, 80);
        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        window.setVisible(true);
    }
}
